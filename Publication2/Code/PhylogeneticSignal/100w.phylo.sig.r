save.wd="/Code/PhylogeneticSignal"
in.wd="/Data/"
envf="100WSc.EnvFactor.csv"
comf="100WSc.OTUtable.csv"
treef="100WSc.Tree.nwk"

#############################
# 1 # load data and log transform environmental factors
#############################
source("/Code/handytool.r")
save.wd=iwd(save.wd)
in.wd=iwd(in.wd)
envin=lazyopen(envf)
comm=t(lazyopen(comf))
dim(envin);dim(comm)
colnames(envin)
env=envin[,3:ncol(envin)]
lnx<-function(v)
{
  minv=min(v)
  if(minv<=0){minv=min(density(v)$x);v=v-minv}
  log(v)
}
envln=sapply(1:ncol(env),function(i){lnx(env[,i])})
colnames(envln)=colnames(env)
rownames(envln)=rownames(env)
envln[,which(colnames(envln)=="pH")]=env[,"pH"]

nworker=20 # paralell thread number

#############################
# 2 # Find centroid factors
#############################
cor.env=cor(envln)
d.env=1-(cor.env^2)

hc=hclust(as.dist(d.env), method = "complete", members = NULL)
plot(hc)
hcct1=cutree(hc,6)

library(vegan)
btdp=vegan::betadisper(as.dist(d.env),group=hcct1,type="centroid",add="lingoes")
grp.lev=sort(unique(hcct1))
centrf=sapply(grp.lev,function(i){which.min(btdp$distances[names(hcct1)[which(hcct1==i)]])})

envs=c("pH","NO3","U",names(centrf))

##################
# 3 # phylogenetic distance
##################
tree=lazyopen(treef)

setwd(save.wd)
if(!file.exists("pd.desc")) 
{
  pd.big=iCAMP::pdist.big(tree = tree, wd=save.wd, nworker = nworker, memory.G = memory.G)
  # output files:
  # path.rda: a R object to list all the nodes and  edge lengthes from root to every tip. saved in R data format. an intermediate output when claculating phylogenetic distance matrix.
  # pd.bin: BIN file (backingfile) generated by function big.matrix in R package bigmemory. This is the big matrix storing pairwise phylogenetic distance values. By using this bigmemory format file, we will not need memory but hard disk when calling big matrix for calculation.
  # pd.desc: the DESC file (descriptorfile) to hold the backingfile (pd.bin) description.
  # pd.taxon.name.csv: comma delimited csv file storing the IDs of tree tips (OTUs), serving as the row/column names of the big phylogenetic distance matrix.
}else{
  # if you already calculated the phylogenetic distance matrix in a previous run
  pd.big=list()
  pd.big$tip.label=read.csv(paste0(save.wd,"/pd.taxon.name.csv"),row.names = 1,stringsAsFactors = FALSE)[,1]
  pd.big$pd.wd=save.wd
  pd.big$pd.file="pd.desc"
  pd.big$pd.name.file="pd.taxon.name.csv"
}

###################
# 4 # niche difference
###################
iwd(save.wd)
library(iCAMP)
envim=envln[,envs,drop=FALSE]
nichedi=iCAMP::dniche(env = envim,comm = comm,method = "niche.value",
                      nworker = nworker,out.dist=FALSE,bigmemo=TRUE,
                      nd.wd=save.wd)

##################
# 5 # mantel correlogram
##################
sum(nichedi$names!=pd.big$tip.label) # this must be zero
mcrl=list()
for(i in 1:length(envs))
{
  message("---Now running i=",i," in ",length(envs),". ",date())
  t1=Sys.time()
  mcrl[[i]]=big.mantel.correlog(x.desc=pd.big$pd.file,x.name=pd.big$tip.label,x.wd=pd.big$pd.wd,
                            y.desc=nichedi$nd[[1]],y.name=nichedi$names,y.wd=nichedi$nd.wd,
                            nworker=nworker,interval=0.02,break.pts=NULL,
                            permutations=999,strata=NULL,
                            diag.in=FALSE,temp.wd=save.wd,stepw=10^6,padjust.method="fdr",
                            cleanup=FALSE,parallelset=TRUE)
  save(mcrl,file = "BigMantelCorrelog.rda")
  print(format(Sys.time()-t1))
}

# End